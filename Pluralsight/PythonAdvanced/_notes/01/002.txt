Advanced Flow Control
Advanced Python
Welcome to the Advanced Python course. My name is Robert Smallshire. Advanced Python is the third in our trilogy of 3 courses, which cover the core Python language, and it builds directly on the knowledge we impart in our Python Beyond the Basics and Python Fundamentals courses, which comprise the second and first parts of our core Python 3 training. Our courses follow a thoughtfully designed spiral curriculum. We visit the same or closely related topics several times in increasing depth, sometimes multiple times in the same course. For example, in Python Fundamentals we covered single class inheritance. In Python Beyond the Basics we covered multiple class inheritance. In this advanced Python course we'll cover what amounts to a type of virtual inheritance using Python's sophisticated abstract base class mechanism. In Python Fundamentals we covered basic techniques you'll use constantly. In this advanced Python course we cover some aspects of Python, which you may use only occasionally. Nevertheless, mastery of the Python language calls for felicity with these features, at least to the extent that you can identify their use in existing code and appreciate their intent. We'll go all the way in this course to show you how to use the most powerful of Python's language features to greatest effect with occasional reminders that sometimes, though, there's a simpler way. Knowing how to use advanced features is what we'll teach in this course. Knowing when to use advanced features, demonstrating a level of skillfulness that can only be achieved through time and experience is the mark of the true master. Specifically in this class, we'll cover advanced flow control, including loop else clauses, try else, and switch emulation. Then we'll go on to examine byte-oriented programming where we'll demonstrate how to interpret and manipulate data at the lowest level in Python. We'll open up objects to inspect their insides where we'll see how objects are represented internally in Python. Then we'll introduce descriptors, showing how to gain complete control over attribute access using a crucial mechanism in Python, which is usually behind the scenes. We'll show how to customize object allocation to make the most efficient use of memory with tactics like interning of immutable objects. That will support our exploration into the process by which class declarations are transformed into class objects by metaclasses, and demonstrate how to write your own metaclasses to customize class construction. Remembering that sometimes there's a simpler way, we'll explain how class decorators can be a simpler, although less powerful, alternative to metaclasses in many cases. We'll finish off this course by showing you how to use abstract base classes to specify and detect class interface protocols, and even how you can make built-in types become subclasses of your own types. That's a lot to cover, but as we go through this course you'll begin to see how many of these pieces fit together. Throughout this course we'll expect you to be familiar with much of the material covered in our Python Fundamentals and Python Beyond the Basics courses. You'll need to be confident of using the built-in types, defining functions, classes, and modules. You'll need to be comfortable defining and using decorators and constructs such as static methods, class methods, properties, and other approaches we have previously introduced, which will be used without introduction. In other words, we expect you to be comfortable with basic and intermediate Python programming techniques before embarking on this course, whether or not you've experienced our earlier classes. You also need a functioning Python 3. 5 or later development environment. Nothing in our courses depends on specific tools other than a Python interpreter, so if you're trying out our code examples for yourself you can use whichever editor you're most comfortable with. For all the demonstrations in this course, we're using JetBrains PyCharm. We need to make a quick note regarding terminology. In Python many language features are implanted or controlled using special methods on objects. These special methods are generally named with two leading and two following underscores. This has the benefit of making them visually distinct, fairly easy to remember, and unlikely to collide with other names. This scheme has the disadvantage, however, of making these names difficult to pronounce, a problem we face when making courses like this. To resolve this issue we have chosen to use the term "dunder" when referring to these special methods. Dunder is a portmanteau of the term double underscore, and we'll use it to refer to any method with leading and trailing double underscores. For example, when we talk about the method, __len__, which is invoked by the len function, we'll say dunder len. These kinds of methods play a big role in this course, so we'll be using this convention frequently. If you'd like a book to support you as you work through the material in this course you can check out The Python Master, which is the companion volume to this advanced Python course covering the same material in written form. By following the URL shown you can obtain the book for a substantially discounted price. The Python Master is the third book in our Python Craftsman trilogy, the first two books being The Python Apprentice, and The Python Journeyman, which correspond to our Python Fundamentals and Python Beyond the Basics Pluralsight courses, respectfully. All three are available to Pluralsight viewers at reduced prices. Like any advanced activity, it takes time and experience to build the skills and control you need to achieve success. With the basic training done, let's launch ourselves into the adventure of advanced Python programming starting out with the twists and turns of advanced flow control.

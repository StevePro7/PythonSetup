While-else for Evaluating Stack Programs
So much for the theory. Is this any use in practice? Well, we must admit that neither of the authors of this course have ever used while else in practice. Almost every example we've seen could be implemented better by another more easily understood construct, which we'll look at later. In this demo our code evaluates simple stack programs where a program is specified as a stack of items where each item is either a callable function, for these we just use any regular Python function, or an argument to that function. So to evaluate 5 + 2 we would set up a stack like this with plus placed first onto the stack, then 2 and then 5. When the plus operator is evaluated its result is pushed onto the stack. This allows us to perform more complex operations, such as (5+2)*3 by pushing multiply onto the stack, then 3, then plus, then 2, and then 5. When evaluating the stack we collect operands until we reach an operator, so we collect 5 and 2, then pop the operator, plus, from the stack, replacing it with 5+2 or 7. Continuing, we pop the operands 7 and 3 from the stack until we reach the operator, multiply. We then push 7 multiplied by 3 back onto the stack, which is 21, the final result. As the stack contains the expression in reverse polish notation the parentheses we needed in the infix version aren't required. In reality, the stack will be a Python list, and the operators will be callables from the Python standard library operator's module, which provides named function equivalents of every python infix operator. It's important to note that when we use Python lists as stacks the top of the stack is the end of the list, so to get everything in the right order we need to reverse our list using the reversed built-in function. For added interest our little stack language also supports comments of strings beginning with a hash symbol, just like Python; however, such comments are only allowed at the beginning of the program, which is at the top of the stack. We'd like to run our little stack program by passing it to a function execute like this. Let's see what such a function might look like, and how it can use the while else construct to good effect. The first thing our execute function needs to do is pop all the comment strings from the top of the stack and discard them. To help with this we'll define a simple predicate function, which identifies stack items as comments, called is_comment. Notice that this function relies on an important Python feature called Boolean Short Circuiting. If item is not an instance of str, then the call to the startswith method will cause an attribute error to be raised; however, when evaluating the Boolean operators and and or Python will only evaluate the second operand if it is necessary to compute the result. In the case that the item is not a string, and the first operand evaluates to false, the results of the Boolean, and, must also be false, with no need to evaluate the second operand. Given this useful predicate, we'll now use a while loop to clear comment items from the top of the stack. The conditional expression for the while statement is the program stack object itself. Remember that using a collection in a Boolean context like this evaluates to true if the collection is non-empty or false if it is empty, or put another way, empty collections are falsy. So this statement reads, while there are items remaining in the program. Within the while block we pop an item from the stack, recall that regular Python lists have this method, which removes and returns the last item from a list. We use logical negation of the results of our is_comment predicate to determine if the just popped item is not a comment. If the loop has reached a non-comment item we push it back onto the stack using a call to append, which leaves the stack with the first non-comment item on top, and then break from the loop. The while loop has an associated else clause to where execution will jump if the while condition should ever evaluate to false, which is when there are no more items remaining in the program. In this clause we print a warning that the program is found to be logically empty, and return early from the execute function. Remember that the while loop else clause is best thought of as a nobreak clause, so when we break from the loop execution skips the else block and proceeds with the first statement after. This loop executes the else block in the case of a search failure. We failed to locate the first non-comment item because there wasn't one. Search failure handling is perhaps the most widespread use of loop else clauses. Now we know that all the remaining items on the stack comprise the actual program. We'll use another while loop to evaluate it. Before the loop we set up an empty list called pending. This will be used to accumulate arguments to function calls, as we'll see shortly. As before, the condition on the while loop is the program stack itself, so this loop will complete and control will be transferred to the while loop else clause when the program stack is empty, which happens when program execution is complete. Within the while loop we pop the top item from the stack, and inspect it with the built-in callable predicate to determine if it is a function. For clarity, we'll look at the else clause first. That's the else clause associated with the if not the else clause associated with the while. If the popped item is not callable we append it to the pending list, and go around the loop again if the program is not yet empty. If the item is callable we attempt to call it, passing any pending arguments to the function using the *args construct. Should the function call succeed, we'll assign the return value to result, push this value back onto the program stack, and clear the list of pending arguments. Should the function call fail, we'll catch the exception, print an error message, and break from the while loop. Remember that this will bypass the loop else clause. When the program stack is empty the else block associated with the while loop is entered. This prints Program successful, followed by any contents of the pending list. This way the program can return a result by leaving non-callable values at the bottom of the stack. These will be swept up into the pending list, and displayed at the end.

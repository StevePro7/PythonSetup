Emulating Switch Statements
Most imperative programming languages include a switch or a case statement, which implements a multi-way branch based upon the value of an expression. Here's an example for the C programming language where different functions are executed depending on the value of the menu_option variable. There's also a default handler for no such option. Although switch can be emulated in Python by a chain of if elif else blocks this can be tedious to write and is error prone because the condition must be repeated multiple times. An alternative in Python is to use a mapping of callables. Depending on what you want to achieve, these callables may be lambdas or named functions. We'll look at a simple adventure game you cannot win in Kafka. py, which will refactor from using if elif else blocks to using dictionaries of callables. Along the way we'll also use try else. The game loop uses two if elif else chains. The first prints information dependent on the players current position, then after accepting a command from the player, the second if elif else change takes action based upon the command. Let's refactor this code to avoid those long if elif else chains, both of which feature repeated comparisons of the same variable against different values. The first chain describes our current location. Fortunately, in Python 3, although not in Python 2, print is a function, and can therefore be used in an expression. We'll leverage this to build a mapping of position to callables called locations. We wrap each call to print in a 0 argument lambda to make it a callable. We'll loop up one of these callables using our position in locations as a key, and call the resulting callable in a try block. Notice here that we don't really intend to be catching KeyErrors from the callable, only from the dictionary lookup, so this also gives us an opportunity to narrow the scope of the try block using the try else construct we learned about earlier. We separate the lookup and the call into separate statements and move the call into the else block. Similarly, we can refactor the if elif else chain, which handles user input into a dictionary lookup for a callable, although this time we used name functions rather than lambdas to avoid the restriction that lambdas can only contain expressions and not statements. Again, we split the lookup of the command action from the call to the command action using the try else construct. Here are the five callables referred to in the dictionary values, go_north, go_east, go_south, and go_west, look, and quit. Notice that using this technique forces us into a more functional style of programming. Not only is our code broken down into many more functions, but the bodies of those functions can't modify the state of the position variable. Instead, we pass in this value explicitly, and return the new value. In the new version mutation of this variable only happens in one place rather than five. Although the new version is larger overall, we'd also claim it's much more maintainable. For example, if a new piece of game state, such as the players inventory were to be added, all command actions would be required to accept and return this value, making it much harder to forget to update the state than it would be in chained if elif else blocks. Let's add a new rabbit hole location, which when the user unwittingly moves into it, leads back to the starting position of the game. To make such a change we need to change all of our callables in the location mapping to accept and return a position and aliveness status. We must also update the call to location_action to pass the current state and receive the modified state. Here are the new location functions; labyrinth, dark_forest_road, tall_tower, and rabbit_hole. Although this may see onerous it's a good thing. Anyone maintaining the code for a particular location can now see what state needs to be maintained. Now let's make the game a little more morbid by adding a deadly lava_pit location, which returns false for the alive status. Here's the function for the lava pit location, which simply prints, you fall into a lava pit, and then returns the current position, but false for aliveness, and of course, we must remember to add this to the location dictionary. We'll also add an extra conditional block after we visit the location to deal with deadly situations, printing, you're dead, if we're not alive, and then breaking from the game loop. Now when we die by falling into the lava pit we break out of the while loop. This gives us an opportunity to use a while else clause to handle non-lethal came loop exits, such as choosing to exit the game, which sets the position variable to non, which is falsy. Now when we quit deliberately, setting position to non, and causing the while loop to terminate we see the message from the else block associated with the while loop. You have chosen to leave the game. You are in a maze of twisty passages, all alike. Okay. Let's go east. You are on a road in a dark forest. To the north you can see a tower. Right, the tower sounds interesting. Let's go north. There is a tall tower here, with no obvious door. A path leads east. Hmm. This game isn't so interesting, let's quit. You have chosen to leave the game. Game over. But when we die by falling into the lava pit, which causes alive to be set to false, causing execution to break from the loop we don't see the message, as the else block is skipped. You are in a maze of twisty passages, all alike. Twisty passages again, ahh, we'll still go east. You are on a road in a dark forest. To the north you can see a tower. I'm still intrigued by that tower. Let's go north again. There is a tall tower here with no obvious door. A path leads east. Hmm, a door. Let's try north. You fall into a lava pit. You're dead. Game over.

Dispatching on Type
That was far too much excitement. Let's look at dispatching on type. To dispatch on type means that the particular implementation of a function, which will be executed, depends, in some way, on the arguments to that function. Python dispatches on type whenever we call a method on an object. There may be several implementations of that method in different classes, and the one that is selected depends on the type of the object. Ordinarily, we can't use this sort of polymorphism with regular functions, and we need to resort to ungainly switch-emulation to root cost the appropriate implementation. The singledispatch decorator, which we'll introduce in this demo, provides a more elegant solution to this problem. Consider the following code, which implements a simple inheritance hierarchy of shapes, specifically, a circle, a parallelogram, and a triangle, all of which inherit from a single base class called shape. Each class has an initializer and a draw method. The initializers store any geometric information peculiar to that type of shape, and pass further arguments up to the shape base class, which stores a flag indicating whether the shape is solid. When we say shape. draw in the main the particular draw method that is invoked depends on whether shape is an instance of Circle, Parallelogram, or Triangle. Of course, on the receiving end it's clear that the object referred to by shape becomes referred to by the first formal argument to the method which, as we know, is conventionally called self. So we say the call is dispatched to the method depending on the type of the first argument. Of course, our code works as you'd expect, and even our little Unicode shape glyphs display properly. This is all very well, and is the way much object oriented software is constructed, but can lead to poor class design because it violates the single responsibility principle. Drawing isn't a behavior inherent to shapes, still less drawing to a particular type of device. In other words, shape classes should be all about shapeness, not about things you can do with shapes, such as drawing, serializing, or clipping. What we'd like to do is move the responsibilities which aren't intrinsic to shapes out of the shape classes. In our case, our shapes don't do anything else, so they simply become containers of data with no behavior, like this. Now our three concrete shape classes, circle, parallelogram, and triangle have only initializers. With the drawing code removed from the classes there are several ways to accomplish implementing the drawing responsibility outside of the classes. In this version of draw we test shape using up to three calls to is instance against circle, parallelogram, and triangle. If the shape object doesn't match any of those classes we raise a type error. This is all good to maintain, and is rightly considered to be very poor programming style. Another approach is to emulate a switch using a dictionary lookup where the dictionary keys are types, and the dictionary values are the functions which do the drawing. Here we look up a drawer function by obtaining the type of the shape in a try block, translating the key error to a type error if the lookup fails or on the happy path of no exceptions, invoking the drawer with the shape and the else clause. This looks better, but is actually more fragile because we're doing exact type comparisons when we do the key lookup, so a subclass of, say, circle wouldn't result in a call to draw circle. The solution to these problems arrived in Python 3. 4 where we can use the singledispatch decorator defined in the Python standard library functools module to perform dispatch on type. Functions which support multiple implementations, dependent on the type of their arguments, are called generic functions, and each version of the generic function is referred to as an overload of the function. The act of providing another version of a generic function for different argument types is called overloading the function. These terms are common in statically typed languages, such as C#, C++, or Java, which are rarely heard in the context of Python. In earlier versions of Python, including Python 2, you can install the singledispatch package from the Python Package Index. To use singledispatch we simply define a function decorated with the singledispatch decorator. Specifically, we define a particular version of the function, which will be called if a more specific overload has not been provided. We'll come to the overloads in a moment. At the top of the file we need to import singledispatch with from functools import singledispatch, and then lower down we implement the generic draw function. In this case, a generic function will simply raise a type error. Remember, this is the version that we'll recall when we haven't provided an overload for a specific type of shape. Recall that decorators wrap the function to which they replied, and bind the resulting wrapper to the name of the original function, so in this case, the wrapper returned by the decorator is bound to the name draw. The draw wrapper has an attribute called register, which is also a decorator, which can be used to provide additional versions of the original function, which work on different types. This is function overloading. Since our overloads will all be associated with the name of the original function, draw, it doesn't matter what we call the overloads themselves, so by convention we call them underscore, although this is by no means required. Whatever name you use will be ignored. Here's an overload for circle, another for parallelogram, and a third for triangle. By doing this we have cleanly separated concerns. Now drawing is dependent on shapes, but not shapes on drawing. Our main function now looks like this. It just calls the global scope generic draw function for each item, and the single dispatch machinery will select the most specific overload if one exists or fall back to the default implementation. We could add other capabilities to shape in a similar way by defining other generic functions, which behave polymorphically with respect to the shape types.

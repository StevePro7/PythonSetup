Double Dispatch with Methods
You need to take care not to use the singledispatch decorator with methods. To see why consider this attempt to implement a generic intersect predicate method on the circle class, which can be used to determine whether a particular circle intersects instances of any of three defined shapes. We've decorated the intersects method with singledispatch, and in this base version we just raise a type error if the shape is unknown. We then provide three specific overloads registered with intersects, which now had to intersect with other circles, parallelograms, or triangles. Each of these methods in turn delegates to a more specific function, circle_intersects_circle, circle_intersects_parallelogram, or circle_intersects_triangle. At first sight this looks like a reasonable approach, but there are a couple of problems here. The first problem, which has been detected here by PyCharm is that we can't register the type of the class currently being defined with the intersects generic function because we haven't yet finished defining it. In this case, we can't register circle because we're in the class definition for circle. The second problem is more fundamental. Recall that singledispatch dispatch is based only on the type of the first argument. When we're calling our new method like this, do_intersect=my_circle. intersects(my_parallelogram), it's easy to forget that my_parallelogram is actually the second argument to circle. intersects, and that my_circle is the first actual argument, which becomes the first formal argument called self. Because self will always be a circle in this case, our intersect core will always dispatch to the first overload irrespective of the type of the second argument. This behavior prevents the use of single dispatchery of methods. All is not lost, however. The solution is to move the generic function out of the class, and to call it from a regular method, which simply swaps the arguments. We move the generic function, intersects, out to global scope, and rename it to intersects_with_circle. The replacement intersects method of circle, which accepts the formal arguments self and shape, now delegates to intersects with circle with the actual arguments swapped to shape and self. To complete this example we would need to implement two other generic functions, intersects_with_parallelogram and intersects_with_triangle, although we'll leave that as an exercise. Doing so would give us a complete implementation of not just single dispatch, but double dispatch, allowing us to do shape. intersects(other_shape) where the function called is selected based upon the types of both shape and other_shape without the shape classes themselves having any knowledge of each other, keeping coupling in the system manageable.

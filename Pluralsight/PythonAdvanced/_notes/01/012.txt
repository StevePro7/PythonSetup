Summary
Well, that just about wraps up this module on advanced flow control in Python 3. Let's summarize what we've learned. We looked at else clauses on while loops, drawing an analogy with a much more well-known association between if an else. We showed how the else block is executed only when the while loop condition evaluates to false. If the loop is executed by other means, such as via a break or a return, the else clause is not executed. As such, else clauses on while loops are only ever useful if the loop contains a break statement somewhere within it. The loop else clause is a somewhat obscure and little used construct. We strongly advice commenting the else keyword with a nobreak remark, so it's clear under what conditions the block is executed. The related for else clause works in an identical way. The else clause is effectively the no-break clause, and is only useful if the loop contains a break statement. They are most useful with for loops when searching. When an item is found while iterating we break from the loop, skipping the else clause. If no items are found, and the loop complete naturally, without breaking, the else clause is executed, and code handling the not-found condition can be implemented. Many uses of loop-else clauses, particularly for searching, may be better handled by extracting the loop into its own function from which execution is returned directly when an item is found, and then the code after the loop can handle the not found case. This is less obscure, more modular, more reusable, and more testable than using a loop else clause within a longer function. Next, we looked at the try except else construct. In this case, the else clause is executed only if the try block completed successfully without any exception being raised. This allows the extent of the try block to be narrowed, making it clearer from where we are expecting exceptions to be raised. Python does not have a switch or case construct to implement multi-branch control flow. We showed the alternatives, including chained if elif else blocks and dictionaries of callables. The latter approach also forces you to be more explicit and consistent about what is required and produced by each branch of the control flow, since you must pass arguments and return values rather than mutating local state in each branch. We showed how to implement generic functions, which dispatch on type using the singledispatch decorator available from Python 3. 4. This decorator can be applied only to module scope functions, not methods, but by implementing forwarding methods and argument swapping we can delegate to generic functions from methods. This gives us a way of implementing double dispatch calls. We're done with Python control flow now, and in the next module we'll be looking at low level byte oriented programming. Thanks for watching, and we'll see you in the next module.

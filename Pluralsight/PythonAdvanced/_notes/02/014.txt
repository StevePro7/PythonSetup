Bitwise Operations on Integers
Let's start right at the bottom with the bitwise operators. These will seem straightforward enough, but our exploration of them will lead us in some murky corners of Python's integer implementation. We covered the bitwise And, bitwise Or, and Shift operators in our Python Fundamentals course when reading binary BMP image files. Now we'll complete the set by introducing the bitwise Exclusive-Or operator and the bitwise compliment operator. Along the way we'll also use bitwise shifts. We'll demonstrate how each of these work, but this will necessitate an interesting detour into Python's integer representation. Recall that we can specify binary literals using the 0b prefix, and we can display integers in binary using the built-in bin function. The bitwise exclusive or operator behaves exactly as you would expect, setting bits in the output value if exactly one of the corresponding operand bits are set. The bitwise compliment or not operator is more unexpectedly difficult to demonstrate, although very easy to use. Here we try to take the compliment of 11110000. You were probably expecting a result of 00001111, although of course, Python doesn't usually print leading 0s, sub 0 b1111 is perhaps more reasonable. Actually, leading 0s are part of the reason we get the surprising -11110001 result. Computer systems typically represent negative integer numbers using a system called Two's Complement. Here's a refresher on how Two's Complement works. Let's see how to represent the number minus 58 in 8 bit Two's Complement, which can represent numbers from -127 to +128. We start with a signed decimal, -58, the value we want to represent. We take the absolute value, which is 58, and represent this in 8 bit binary, which is 00111010. The same binary pattern can be interpreted as the unsigned decimal 58. Now, as the first part of the Two's Complement operation, we flip all the bits, a bitwise not operation to give 11000101. This is where the two in Two's Complement comes from. The complement operation is done in base two, binary. This gives a bit pattern that would be interpreted as 197 as an unsigned integer, although that's not too important here. Finally, we add 1, which gives the bit pattern 11000110, which could be interpreted as 198 is an unsigned integer, which notice, is outside the range -127 to +128 allowed for the signed integers. This is the Two's Complement 8 bit representation for -58. Two's Complement has particular advantages over other representations, such as sign-bit and magnitude schemes. For example, Two's Complement works naturally with arithmetic operations, such as addition and subtraction involving negative numbers. Recall that Python 3 uses arbitrary precision integers, that is, Python integers are not restricted to 1, 2, 4, or 8 bytes, but can use as many bytes as are necessary to store integers of any magnitude. However, Two's Complement presents problems when used with unlimited precision. When we take the complement by flipping the bits, how many leading 0s should we flip? In a fixed precision integer representation the answer is obvious, not so with variable bit width integers, and when you are flipped an infinite number of leading 0s to give an infinite number of leading 1s how do you interpret the results? Of course, Python doesn't really represent negative integers using an infinite number of leading 1s, but conceptually this is what's going on. This is why when asked to represent negative numbers in binary Python actually uses a leading unary minus with magnitude representation, rather than gibing the unsigned binary Two's Complement representation. This means we don't easily get to see the internal bit representation of negative numbers using bin. In fact, we can't even determine what internal representation scheme is used. When our use of the bitwise operators, such as the bitwise not operator, results in a bit pattern that would normally represent a negative integer in Two's Complement format, Python displays that value in sign magnitude format, obscuring the result we wanted. To get the actual bit pattern we need to do a little extra work. Let's return to our earlier example. Let's make v equal to the value 11110000 in binary. This is equal to 240 in signed decimal. Now we'll use the bitwise not operator. Working in binary, we need an 8-bit representation for 240, although to accommodate the Two's Complement representation for the positive integers we need to accommodate at least one leading 0, so really we need at least a 9-bit representation. It is the bits of this 9-bit representation to which the bitwise not is applied, giving 100001111. This is the Two's Complement representation of -241. Displayed back in the signed magnitude representation Python uses when displaying binary numbers, -241 is displayed as -0b11110001. So much for an explanation, but how do we see the flipped bits arising from our application of bitwise not in a more intuitive way? One approach is to manually take the Two's Complement of the magnitude or absolute value of the number. Unfortunately, this also uses the bitwise not operator, and so we end up chasing our tail trying to escape the cleverness of Python's arbitrary precision integers if we try this in Python 3. Another approach is to rely on the characteristics of Two's Complement arithmetic. Take the signed interpretation of the Two's Complement binary value, in this case -241, add to it 2 to the power of the number of bits used in the representation, excluding the leading 1s, so that's 2 to the 8 or 256. Minus 241 plus 256 is 15, and 15 has the 00001111 bit pattern we're looking for, the binary value we expected to get when we applied bitwise not to 11110000. Remember that the Two's Complement of a positive number is itself, so our function needs to take account of this. Also see how we use bitwise shift to raise two to the power of number of bits by shifting the value one to the right by the exponent of eight places. If you have difficulty understanding how this works, don't worry. It is tricky, and 15 minutes with a pencil, paper, and a Python interpreter will be well rewarded. A less usable, but perhaps more obvious approach, is to use bitwise and with a mask of ones to discard all the leading ones in negative results. This effectively specifies to how many bits of precision we want the result to be presented. See how asking for a 9-bit result reveals the leading 1 of the Two's Complement representation? In fact, since Python 3. 2 we can ask Python how many bits are required to represent the integer value using the bit_length method of the integer type, although note that this excludes the sign. Bit_length of 32 is 6, the bit_length of 240 is 8. The bit_length of -241 is also 8, and the bit_length of 256 is 9.

The Bytes Type in Depth
Let's take a look at the bytes type in-depth. We first introduced the bytes type way back in the early part of our Foundational Python Fundamentals course. We did this to highlight the essential differences between str, which is an immutable sequence of Unicode code points, and bytes, which is an immutable sequence of, well, bytes. This is particularly important if you're coming to Python 3 from Python 2 where str behaved differently. At this point, you should be comfortable with the bytes literal, which uses the b prefix. The default Python source coding coding is UTF-8, so the characters used in a literal byte string are restricted to printable 7-bit ASCII characters. That is, those with codes from 0 to 127 inclusive, which aren't control codes. This is okay because it's 7-bit ASCII. 7-bit control codes or characters which can't be encoded in 7-bit ASCII result in a syntax error. Norwegian characters like Å and Ø are not 7-bit ASCII. To represent other bytes with values equivalent to ASCII control codes and byte values from 128 to 255 inclusive, we must use escape sequences with \x. Notice that Python echoes these back to us as escape sequences too. This is just a sequence of bytes, not a sequence of characters. If we want a sequence of Unicode code points we must decode the bytes into a text sequence of the str type, and for this we need to know the encoding. In this case, I'll use latin1. When we retrieve an item from the bytes Offline Bundle by indexing we get an int object, not a 1-byte sequence. This is another fundamental difference between bytes and str. Slicing of bytes objects, however, does return a new bytes object. There are a few other forms of the bytes constructor it's good to be aware of. You can create a 0 length byte sequence simply by calling the constructor with no arguments. You can create a 0 field sequence of bytes of a given length by passing a single integer to the bytes constructor. You can also pass an iterable series of integers. It's up to you to ensure that the values are non-negative and less than 256 to prevent a ValueError being raised. One option, if you need to construct a bytes object by encoding a Unicode str object is to use the two argument form of the bytes constructor, which accepts a str in the first argument, and the name of an encoding for the second. Finally, there's a class method, which is a named factory function for creating a bytes object from a string consisting of concatenated, two-digit, hexadecimal numbers. There isn't a method to go in the other direction, so we have to use something like this where we use a generator expression to convert each byte to its hex representation, stripping the leading ox from each resulting string using slicing.

The memoryview Type
Python has a built-in type called memoryview, which wraps any existing underlying collection of bytes, which supports something called the buffer protocol. The buffer protocol is implemented at sea level inside the Python interpreter and isn't a protocol in the same sense that we use the word when talking about Python level sequence and mapping protocols. In fact, the memoryview type implements the Python level sequence view protocol, allowing us to view the underlying byte buffer as a sequence of Python objects. Our previous example required that we read the data from the file into a byte array, and then translated it with struct unpack into a tuple of numeric objects, effectively duplicating data. We're going to change that example now to use memoryviews, avoiding the duplication. We can construct memoryview instances by passing any object that supports the buffer protocol C API to the constructor. The only built-in types which support the buffer protocol are bytes and byte array. We'll construct a memory view from the buffer just after our diagnostic print out with this line of code; mem = memoryview(buffer). To explore the capabilities of memoryview we could use a debugger, such as PDB or the one here in PyCharm to stop the program just after this line, but we'll introduce you to another technique from the Python standard library code module, code. interact. This function will suspend the program and drop us to the REPL. By passing a reference to the local namespace we can get access to the live variables in our program, including our memoryview object, mem. We use a call to the local's built-in function to get a reference to the current namespace. Now when we run our program we get a REPL prompt at which we can access our new mem object. The memoryview object supports indexing, so retrieving a byte at index 21 and converting to hexadecimal gives us 3f, which is what we would expect. Being bona-fide sequences memory view objects support slicing. Here we slice from bytes 12 to 18. Crucially, memory view slices are also memory views. There's no copying going on here. The 0th byte of the slice has value e0. Much in the same way as we use the struct module to interpret binary data as native types, we can use the memory view cast method to do the same. This method accepts the same format codes as are used by the structs module, expect that only a single element code is permitted. In other words, the interpreted items must all be of the same type. We know that the bytes in the 12 to 18 slice represent 3 unsigned short int values, so by passing capital H to the cast method we can interpret the values that way. Notice that cast also returns a memoryview, but this time one that knows the type of its elements. This gives us the same unsigned integer values that we wrote from our original C program that created the binary file. Alternatively, we can use the memory view to list method to convert the series of elements to a list. Now we're finished with the interactive session provided by Code Interact. We can send the end of file character, just as you normally would to terminate a REPL session, Ctrl+D on Unix or Ctrl+Z on windows. Your program will then continue executing. Before moving on we'll remove the code interact line, so our program runs to completion and uninterrupted next time. Let's use the ability to slice and cast memory views to modify our vector and color types to use the bytes buffer as the underlying storage. Our modified vector class now looks like this. The initializer accepts a memoryview, which we expect to expose floats. We validate this by checking the format code returned by the memoryview format attribute against a string containing f and d. Those code for single and double precision floats respectively. We also checked that the memoryview exposes at least three items. Note that when used with memoryview len returns the number of items, not the number of bytes. The only instance attribute of vector_mem now holds a reference to the memoryview. Our old instance attributes are replaced by read only properties which perform the appropriate lookups in the memoryview. Since we can use properties to replace attributes our dunder repr implementation can remain unmodified. The modified color class works exactly the same way, except now we check that the memoryview wraps unsigned integer types. Our vertex class, which simply combines a vector and a color can remain unchanged, although our make_colored_vertex factory function needs to be changed to accept a memory view, specifically one that is aligned with the beginning of a vertex structure. The function now slices the vertex memory view into two parts for the vector and color respectively, and casts each to a typed memory view. These are used to construct the vector and color objects, which are then passed on to the vertex constructor. Back in our main function, after creation of the mem instance, we'll need to rework our main loop. We start by declaring a couple of constants describing the size of a vertex structure, and the stride between successive vertex structures. This allows us to take into account the 2 byte padding between structures. Next, we'll set up a generator expression which yields successive memory views into whole vertex structures. Remember that each slice into mem is itself a memoryview. This time rather than an expressive for loop to build the list of vertices we'll use a list comprehension to pass each vertex memoryview in turn to make colored vertex. Running this program, we can see we get exactly the same results as before, except that now our vector and color objects are backed by the binary data we loaded from the file with much reduced copying.

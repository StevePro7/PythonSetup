Memory-mapped Files
There's still one copy happening though, the transfer of bytes from the file into our buffer bytes object. Not a problem for our trifling 80 bytes, but for very large files this could be prohibitive. By using an operating system feature called memory mapped files we can use the virtual memory system to make large files appear as if they are in memory. Behind the scenes the OS will load, discard, and sync pages of data from the file. The details of this are operating system dependent, but the pages are typically only 4Kb in size, so this can be memory efficient if you need to access relatively small parts of large files. Memory-mapped file support in Python is provided by the standard library mmap module, which contains a single class, also called mmap, which behaves like a mix between a byte array and a file like object. The mmap instance is created around a file handle on Windows or a file descriptor on Unix, either of which can be obtained by calling the fileno method of a regular file object. In fact, mmap instances support the C API buffer protocol, and so can be used as the argument we pass to our memoryview constructor. Let's modify our example program to do so. All this requires is that we import the mmap module at the top of our file and modify our main function to retrieve the file handle or descriptor, passing it to the mmap constructor. As with any other file-like object, mmap objects must be closed when we're done with them. We can either call the close method explicitly or, more conveniently, use the mmap object with a context manager. We'll do the latter. The only difference here is that buffer is now a memory map file rather than the byte sequence, as it was previously. We've avoided reading the file into memory twice; once into the OS maintained file cache, and again, into our own collection by directly working on the operating systems view of the file. This works after a fashion when we run it, insofar as our vertex objects are created with the memory-mapped file backing store; however, we get a nasty failure when the mmap object is closed by the context manager, which tells us that exported pointers exist. The reason for this is that at the point the mmap object is closed by the context manager we still have a chain of extend memoryview objects which depend ultimately on the mmap object. A reference counting mechanism in the buffer protocol has tracked this and knows that the mmap still has memoryview instances pointing at it. Thinking about our live object graph, there are two local variables, which ultimately hold references to the memory map file, mem, which is our lowest level memoryview, and vertices, which is the list of vertex objects. There are a couple of approaches we could take here. We could arrange for the memoryview release method to be called on the memoryview object inside our vector and color instances. This method deregisters the memoryview from any underlying buffers and invalidates the memoryview, so any further operations with it raise value errors. This would just move the problem though. Now we'd have zombie vector and color instances containing invalid memoryviews. By explicitly removing these name bindings, using two invocations of the del statement, we can clean up the memoryviews, so the memory map can be torn down safely. Better to respect the constraint in our design, the lifetime of our memory-mapped file backed objects must be shorter than the lifetime of our memory mapping. With this change in place our program runs flawlessly.

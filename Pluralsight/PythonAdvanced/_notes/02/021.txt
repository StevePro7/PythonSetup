Summary
Let's summarize what we've covered in this module. Our review of Python's bitwise operators, including exclusive or and compliment, led us down the path of understanding how Python internally represents and externally presents arbitrary precision integer values at the bit level. To print bit patterns for values which equate to negative numbers you can sign extend the results by using bitwise and with a binary value consisting of 1 bits. We reviewed the constructors and some key methods of the immutable binary sequence type bytes and the mutable binary sequence type, bytearray. We showed how to interpret a series of bytes as native or C language types, such as short unsigned integer, translating them into compatible Python types using the struct module of the Python standard library. We demonstrated how to display byte streams in an easily readable hexadecimal format using the hexlify function in conjunction with some simple formatting expressions. We explain that a detailed understanding of how C compilers align data structures on certain byte or word boundaries can be crucial to correctly reading the data files produced by C or C++ programs. We introduced memoryview for obtaining copy free views, slices, and type casts from underlying byte sequences. We touched on the use of the really useful interact function from the standard library code module, which allows us to drop to a REPL at any point in the program and resume execution later, and we showed that memory-mapped files implemented with mmap module implement the buffer protocol, and so can be used as the basis for memory view objects, further reducing the amount of data copying when reading files. There's a lot to be learned about low-level, byte-oriented programming in Python, including writable memory views, shared memory with mmap, and interfacing to native C and C++ code. We can't possible cover all that in this course, but we've shown you the starting points for your own explorations. Thanks for watching, and we'll see you in the next module.

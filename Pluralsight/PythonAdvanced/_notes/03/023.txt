How are Python Objects Represented?
Let's start with a simple class to represent two-dimensional vectors called simply, vector. This has an initializer, which accepts the two components of the vector, x and y, and these are stored on two instance attributes also called x and y. We also include a dunder wrapper, so that we can print a nice textural representation of our vector objects. Let's instantiate an object of this class in the REPL with components 5 and 3. In the list returned by the built-in dir function we see two named attributes, x and y, along with many of Python's special dunder attributes, quite a few of which we've explained previously in Python Fundamentals of Python Beyond the Basics. One attribute in particular is of interest to us today, and that is dunder dict. Let's see what this is. As its name indicates, dunder dict is indeed a dictionary, one which contains the names of our objects attributes as keys, and the values of our objects attributes as, well, values. Here's further proof, if any were needed, that dunder dict is a Python dictionary. We can retrieve the type of v. dunder dict, which is dict. We can retrieve attribute values directly from dunder dict by indexing into the dictionary with square brackets, just like a normal dictionary because it is a normal dictionary. We can even modify attribute values through dunder dict. Going further, we can even remove attributes entirely. As you might by now suspect, we can also test for their existence using the in operator, and add new attributes into the dictionary, and thereby into our object. Although all of these direct queries and manipulations of dunder dict are possible, for the most part, you should prefer to use the built-in functions getattr, hasattr, delattr, and setattr. Direct access to dunder dict does have legitimate uses though, and it's essential to be aware of it's existence and how and when to use it for advanced Python programming. Our vector class, like most vector classes, has hard wired attributes called x and y to store the two components of the vector. Many problems, though, require us to deal with vectors in different coordinate systems within the same code or perhaps it's just convenient to use a different labeling scheme, such as u and v instead of x and y in a particular context. Let's see what we can come up with. In this code we accept a double star keywords args argument, which is received into the coords dictionary, which we will then use to update the entries in dunder dict. Remember that dictionaries are unordered, so there's no way to ensure that the coordinates are stored in the order they are specified as actual function arguments. Our dunder repr implementation must iterate over the dictionary, sorting by key for convenience. Our modified vector class allows us to provide arbitrary coordinate names. Here we set p to three and q to seven. This is all very well, but our coordinates are now essentially public attributes of our vector objects. What if we want our vector class to be an immutable value type, so we provide values to the constructor, which can't be subsequently changed? Ordinarily we will do this by prefixing our attributes with an underscore to signal that they are implementation details, and then provide a property with only a getter to prevent modification. In this case, though, we don't know the attribute names in advance, so we can't declare a property getter, which must be named at class definition time, not at object instantiation time. We'll show how to work around this using the special dunder getattr method, but first let's change our dunder init method to store data in private attributes and add dunder repr to report them correctly. In this version of the code we use a dictionary comprehension to associate new names with a prefix underscore with each existing value and assign this to a new dictionary called private_coords. This is what we then use to update dunder dict. In the dunder repr code we must remember to strip the leading underscore when displaying the representation, in this case, by using string slicing to emit the first character. We can construct and represent vector instances just as before. Here we use p=9 and q=3, but now the attributes are stored in private attributes called _p and _q. Because of this we can no longer access Python directly. It doesn't exist as an attribute.

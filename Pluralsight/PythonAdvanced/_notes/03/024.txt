Overriding __getattr__
What we'd like to do is to fake the existence of p for read access, and to do that we need to intercept attribute access before the AttributeError is raised. To do that we could use dunder getattr. Notice that there are two very similarly named methods, dunder getattr, and dunder getattribute. The former is only called when regular attribute lookup fails. The latter is called for all attribute access, irrespective of whether an attribute of the requests name exists of not. For our case, we'll be using dunder getattr to intercept lookup failures. Here's our vector definition, which incorporates dunder getattr. We've just added a simple stub that prints the attribute name. When we request non-existent attributes the name of the attribute is now printed. Here we ask for p and it prints name = p, and when we ask for q it prints name = q, but when we request the name of an attribute that does exist we simply get the attribute value, indicating that dunder getattr isn't being called in these cases. Now we can modify dunder getattr to prepend the underscore to the name, and retrieve the underlying attribute for us. At first sight, this appears to work just fine. Now we can retrieve p and q, but there's some serious problems lurking here. The first is that we can still assign to p and q. Here we set p to 13. Remember that there wasn't really an attribute called p, but Python has no qualms about creating it for us on demand. Worse, because we have unwittingly brought p into existence, dunder getattr is no longer invoked for requests for p, even though our hidden attribute, _p, is still there behind the scenes with a different value. Currently, p has a value of 13, and _p has a value of 5.

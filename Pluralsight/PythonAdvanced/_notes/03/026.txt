Pitfalls with __getattr__
Although dunder getattr works fine with attributes we've carefully faked, such as p, look what happens when we try to access an attribute for which there is no fake support, such as x. We get a runtime error, maximum recursion depth exceeded while calling a Python object. In other words, we've got infinite recursion. This happens because our request for attribute x causes dunder getattr to look for an attribute, _x, which doesn't exist. This in turn invokes dunder getattr again to look up attribute __x, which doesn't exist, and so on recursively until the Python interpreter exceeds its maximum recursion depth and raises a runtime error. To prevent this happening you might be tempted to check for the existence of the private attribute using hasattr, like this, raising an AttributeError if the private attribute can't be found. Unfortunately, this doesn't work either, since it turns out that hasattr also ultimately calls dunder getattr in search of the attribute. What we need to do is directly check for the presence of our attribute in dunder dict using the not in operator. This now works as we would wish. We can create a vector with components p=9 and q=14. We can display the vector, which echoes those values back to us. We can query individual components, such as p, which is of course equal to nine, but when we request x, which is not defined, an AttributeError is raised, as we would expect. In fact, attribute lookup in Python follows a pretty complex procedure, so instead of invoking that procedure again, by calling getattr, we can just directly return the attribute from dunder dict. This also enables us to switch to easier to ask forgiveness than permission, EAFP style programming, rather than look before you leap, LBYL style programming. Now the code attempts to retrieve the attribute with a private name directly from dunder dict. If it's not there a KeyError is raised, and in the except KeyError block we convert that to an AttributeError. Of course, the easier to ask forgiveness than permission version has exactly the same behavior as the look before you leap version.

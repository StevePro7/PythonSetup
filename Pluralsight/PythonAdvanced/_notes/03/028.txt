Customizing Attribute Storage
There is no requirement for us to store attributes directly in dunder dict. Here's an example of a subclass of vector called ColoredVector that stores immutable red, green, blue color along with the immutable vector components. Internally we store the red, green, blue channels in a list, which is assigned to the attribute called color. We override both dunder getattr and dunder setattr to provide read and write access to the color channels, being careful to forward requests to the super class when necessary. Here we create a ColoredVector called cv with color components red, 23, green, 44, blue, 238, and special components p=9, and q=14. Our code allows us to retrieve these attributes, red, green, p, and q as if they were just regular attributes, although the storage mechanisms for the vector components and the color components are quite different. When we do dir(cv) we see _p and _q for the vector components, and color for the color components. There's a gremlin lurking here though. Our dunder repr implementation in the base class makes an assumption, which is no longer valid. It assumes all attributes are prefixed with an underscore internally, and doesn't know about color. This causes our dunder repr to behave in unexpected ways. This is surprisingly hard to fit elegantly without the derived ColoredVector class knowing too much about implementation details of the vector base class. We believe it should be possible to derive from a class without knowing how it works. The base class dunder repr makes assumptions about the contents of its dunder dict, which it cannot reasonably expect to be respected by subclasses. As an exercise, we recommend changing vector, so it stores it's components in a dedicated dictionary separate from dunder dict, although of course, this dictionary itself will need to be stored in dunder dict. Here's another fix which works by duplicating and modifying some of the logic in the base class into an override of dunder repr. This method override works by removing the attribute named color from the list of keys before using the same logic as the super class to produce the string of sorted coordinates. The color channel values are accessed in the normal way, which will invoke dunder getattr. It's worth bearing in mind that this example demonstrates the awkwardness of inheriting from classes, which were not deliberately designed as base classes. Our code serves its purpose in demonstrating customized attribute access, but we couldn't recommend such a use of inheritance in production code.

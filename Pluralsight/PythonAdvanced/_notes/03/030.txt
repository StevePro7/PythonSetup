Overriding __getattribute__
Now let's look at dunder getattribute as opposed to dunder getattr. Recall that dunder getattr is called only in cases when normal attribute lookup fails. It's our last chance for us to intervene before the Python runtime raises an attribute error, but what if we want to intercept all attribute access? In this case, we can override dunder getattribute. I use the term override advisedly because it's the implementation of dunder getattribute in the ultimate base class object that is responsible for normal lookup behavior, including calling dunder getattr. This level of control is seldom required, and you should always consider whether dunder getattr is sufficient for your needs. That said, dunder getattribute does have its uses. Consider this class, which implements a logging proxy, which logs every attribute retrieval made against the target objects supplied to the constructor. Since dunder getattribute intercepts all attribute access through the dot operator we must be very careful never to access attributes of the logging proxy through the dot. In the initializer we use the dunder setattr implementation inherited from the object super class to do our work. Inside dunder getattribute itself we retrieve the attribute called target using a call to the super class implementation of dunder getattribute, which remember, implements the default lookup behavior. Once we have a reference to the target class we delegate to the getattr built-in function. If attribute lookup on the target fails we then raise an attribute error with an informative message. Note how careful we must be even to return our object's dunder class. If attribute retrieval was successful we report as much before returning the attribute value. Let's see this in action. Note we're doing this in the regular Python REPL in a terminal rather than using the PyCharm REPL simply because PyCharm itself performs a great many invocations of dunder getattribute in its console to support code completion. We create a ColoredVector called CV with colors red 23, green 44, blue 238, and vector components p=9 and q=14. We then wrap a LoggingProxy called CW around the ColoredVector, CV. When we retrieve the p attribute from CloudWatch our dunder getattribute code is invoked, and the message is printed. Likewise, for the red attribute. So far so good, but what happens when we write to an attribute through the proxy? In this example both writes appear to be accepted without error, although only one of them should be. Remember, the vector component should be immutable. Only the colors are mutable. In fact, though, neither of the writes succeeded. Let's check by retrieving the attributes. It looked like p was set to 19, but it still has the value 9. The color red should have been set to 5, but it still has the value 23. What's happening here is that our attribute writes to the CW proxy are invoking the inherited dunder setattr on the object base class, which is actually creating new attributes in the logging proxy instances, dunder dict, however, reads through the proxy, correctly bypass this dunder dict, and are redirected to the target. In effect, the proxy dunder dict has become write only. The solution to this is to override dunder setattr on the loggingproxy too. In the implementation we retrieve the attribute called target using a call to the superclass implementation of dunder getattribute. We'll then use the setattr built-in function to set the attribute on the target. With dunder setattr in place we can successfully write through the logging proxy to modify mutable attributes. Here we update red to 55, and attempted writes to immutable attributes, such as p, are rejected as we intended.

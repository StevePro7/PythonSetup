Trading Size for Dynamism with Slots
We'll finish off this part of the course with a brief look at a mechanism in Python for reducing memory use, slots. As we have seen, each and every object stores it's attributes in dictionary. Even an empty Python dictionary is quite a hefty object weighing in at 288 bytes. Here we create an empty dictionary and use the getsizeof function from the sys module to measure its size. If you have thousands or millions of objects this quickly adds up, causing your programs to need megabytes or gigabytes of memory. Given contemporary computer architectures, this tends to lead to reduced performance, as CPU caches can hold relatively few objects. Techniques to solve the higher memory usage of Python programs can get pretty involved, such as implementing Python objects in a lower level language, such as C or C++, but fortunately Python provides the slots mechanism, which can provide some big wins for low effort with tradeoffs that will be acceptable in most cases. Let's take a look. Consider the following class to describe the type of electronic component called a resistor. In our simple model resistors have a resistance in ohms, a tolerance in percent, and a power capability in watts. We simply store these as three instance attributes of the same name. It's difficult to determine the size in memory of Python objects, but with care we can use the getsizeof function in the sys module. To get the size of an instance of resistor we need to account for the size of the resistor object itself and the size of its dict. Here we create a 10 ohm resistor, r10, with a resistance of 10 ohms, a tolerance of 5%, and a power of 0. 25 of a watt. Its size weighs in at 152 bytes. Python objects being highly dynamic, dictionary-based objects we can add attributes to them at runtime and see if this is reflected as an increased size. Let's add a cost attribute to r10 of $0. 02. Now its size has shot up to 248 bytes. This is quite a big object, especially when you consider that the equivalent struct in the C programming language would weigh in at no more than 64 bytes with very generous precision on the number types. Let's see if we can improve on this using slots. To use slots we must declare a class attribute called dunder slots. To dunder slots we assign a list containing the strings, resistance_ohms, tolerance_percent, and power_watts. Now look at the space performance of this new class. We can instantiate resistor, just as before, and retrieve its attributes in exactly the same way; however, its size is much reduced from 152 bytes down to 64 bytes, less than half the size. There's always a tradeoff though, as we can no longer dynamically add attributes to instances of resistor. This is because the internal structure of resistor no longer contains a dunder dict. For most applications slots won't be required, and you shouldn't use them unless measurements indicate that they may help, as slots can interact with other Python features and diagnostic tools in surprising ways. In an ideal world slots wouldn't be necessary, and in our view they're quite an ugly language feature, but at the same time, we've worked on applications where the simple addition of a dunder slots attribute has made the difference between the pleasure of programming in Python and the pain of programming in a lower level, but more efficient language. Use slots wisely.

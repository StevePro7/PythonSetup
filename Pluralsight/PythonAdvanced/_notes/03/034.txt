Summary
Let's summarize what we've covered in this course module. We've discovered that Python objects store their attributes internally within a dictionary called dunder dict, which maps attribute names to attribute values. We showed that instance attributes can be created, retrieved, updated, and deleted by direct manipulation of dunder dict. We showed how any failure to retrieve an attribute by normal means causes the dunder getattr special method to be invoked. The implementation of dunder getattr can use arbitrary logic to fake the existence of attributes programmatically. Similarly, assignment attributes can be customized by overriding dunder setattr, and deletion of attributes can be customized by overriding dunder delattr. Calls to the hasattr built-in function may also invoke dunder getattr, so dunder getattr implementations need to be particularly careful to avoid non-terminating recursion. Occasionally, it's necessary to customize all attribute lookup, even for regular attributes. In these cases, the default lookup machinery and the special dunder getattribute method of the object based class may be overridden, taking care to delegate to the base class implementation as necessary via a call to super. Method callables are stored in the dunder class. dunder dict dictionary. Slots are a quick way to make Python objects more memory efficient at the cost of them being less dynamic. In the next module we'll be looking at even more sophisticated ways to customize attribute access using a Python feature called descriptors. Thanks for watching, and we'll see you in the next module.

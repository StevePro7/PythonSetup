Descriptors
Introducing Descriptors
Hello. My name is Robert Smallshire. Welcome to the fourth module of the Advanced Python course. In this module we'll investigate a feature of Python you've been using, perhaps unknowingly, called descriptors. Descriptors are the mechanism used to implement properties in Python. We covered properties thoroughly in Python Beyond the Basics, but we'll start here with a short recap. In Python Beyond the Basics we showed how to create properties using the property decorator. In this module we'll dig deeper and show how to create properties in the raw using the property constructor. Then we'll show how to create a specialized property by defining a custom descriptor, which implements the descriptor protocol. We'll round off by demonstrating that there are two categories of descriptor, data descriptors and non-data descriptors, and we'll show how these interact with Python's somewhat complicated attribute lookup rules. As promised, we'll start with a very brief review of properties, our entry point into the world of descriptors. To explain descriptors we'll be building this simple class to model planets, such as Pluto here, focusing on particular physical attributes, such as size, mass, and temperature. Let's start with this basic class definition for a planet in planet. py consisting of little more than an initializer. There are no properties here yet. We'll add them in a moment. Inside the planet initializer we initialize the planet's name, its radius in meters, its mass in kilograms, its orbital period in seconds, and its surface temperature in Kelvin. This Planet class is simple enough to use. Here we create an instance of planet called Pluto, which we give a radius of 1184Km, together with the correct values for its other physical quantities. Of course, we can easily retrieve the value of the radius_metres attribute. Unfortunately, our code allows us to represent nonsensical situations, such as setting a negative radius, either by directly mutating an attribute like this, here we set the radius of Pluto to -10, 000 meters or simply by passing nonsense, such as a 0 mass and negative orbital period or a temperature below absolute 0 to the constructor. We already know how to improve this sort of code, by wrapping our instance attribute in property getters and setters, which perform validation by checking the physical quantities are positive. We then assigned through those properties in the initializer to get validation on constriction for free. Here we've wrapped radius_metres, mass_kilograms, orbital or period seconds, and surface temperature kelvin in properties setters and getters. From a robustness standpoint this code is much better. For example, we can no longer construct massless planets. Now we get a value error with a helpful message telling us that a mass in kilograms with a value of 0 is not positive. The tradeoff, though, is that the amount of code is exploded, and worse, there's a lot of duplicated code checking that all those numeric attribute values are non-negative. Descriptors will ultimately provide a way out of this, but first we need to do a little more unraveling of properties to aid our understanding.

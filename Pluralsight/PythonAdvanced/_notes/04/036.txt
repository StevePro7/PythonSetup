Properties are Descriptors
Back in Python Beyond the Basics we introduced property as a function decorator for property getters. To briefly recap, a getter method, which encapsulates direct attribute access, is decorated by the property decorator, which creates a property object. The getter function is bound to an attribute of the property object called fget, and the original name of the getter is conceptually rebound to the property object. The property object also has an attribute called setter, which is in fact another decorator. When a setter method is decorated by the setter the original property object is modified to bind and attribute called fset to the setter method. The property object effectively aggregates the getter and setter into a single property object which behaves like an attribute because it is a descriptor. Shortly we'll learn how it is able to appear so attribute like, but first let's unravel properties a bit more. Remember that function decorators are just regular functions which process an existing function and return a new object, usually a new function, which wraps the decorated function. Instead of using decorator syntax to apply the decorator to a function we can just define a regular undecorated function, and then pass the function to the decorator, rebinding it to the same or indeed any other name. Given that decorators are just functions, let's rework our code to apply property explicitly using regular function call syntax, avoiding the special decorator application syntax using the @ symbol. When doing this it's important to note that the property function supports several arguments for simultaneously supplying the getter, setter, and deleter functions, along with a doc string value. In fact, help property makes this quite clear. As you can see, we can separately define our getter and setter functions, then call the property constructor within the class definition to produce a class attribute. Let's use this form in our Planet class for the numerical attributes. First we'll remove the property decorator from the getter functions before removing the setter decorator from the setter functions. Now we'll prefix the names of the getter functions with _get_ and the names of the setter functions with _set_. We use single underscore prefixes here because these are not special methods. Finally, we create a property object using the property function. You can think of it as a constructor call in this context, passing the pair of getter and setter functions. Continuing, we need to do the same for the mass_kilograms property, the orbital_seconds property, and the surface_temperature_kelvin property. If you think this form of property set up is a retrograde step compared to the decorator form we'd agree with you. There's a good reason we introduce properties as decorators first, nevertheless, it reinforces the notion that property is simply a function, which returns an object called a descriptor bound to a class attribute. The runtime behavior of this code hasn't changed at all. We can still create objects, retrieve attribute values through properties, and attempt to set attribute values through properties with rejection of nonsensical values. We already know what sort of operations we can perform with a descriptor. We can get a value, set a value, and delete a value. In the case of property, these getting, setting, and deleting operations call functions of our own, which query and manipulate instance attributes, although in general, the descriptor operations can be implemented to do almost anything.

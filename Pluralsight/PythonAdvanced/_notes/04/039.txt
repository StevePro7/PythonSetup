Data vs. Non-data Descriptors
You may here the terms data descriptor and non-data descriptor, but what do they mean? A non-data descriptor is a descriptor which implements only the dunder get method, and so is read only. So called data descriptors sport both the dunder get and dunder set methods and are writable. The distinction is important because of the precedence of attribute lookup. Behind the scenes the machinery in object. dunder getattribute, which is responsible for all attribute lookup in Python, transforms a call like this into a call like this. In fact, a precedence chain controls attribute lookup according to the following rules. If an instance is dunder dict has an entry with the same name as a data-descriptor the data-descriptor takes precedence. If an instance is dunder dict has an entry with the same name as a non-data descriptor the dictionary entry takes precedence. These statements are true, but quite a mouthful. Another way of looking at it is that attribute lookup precedes first the data descriptors, such as properties defined in the class, then to instance attributes in dunder dict, and then onto non-data descriptors in the class again. A simple experiment should make things clearer. Here we define a DataDescriptor, a NonDataDescriptor, and a class which uses them both called Owner. We'll import all this into a REPL session. After we've created an instance of Owner we'll retrieve the attribute A, set an item in the instance dictionary with the same name, and retrieve A again. Since this is a data descriptor the first rule applies, and the data descriptor takes precedence when we call obj. a. Now let's try attribute b. The first time we access obj. b there is no entry of the same name in the instance dictionary, so the NonDataDescriptor takes precedence. After we've added a b entry into dunder dict the second rule applies, and the dictionary entry takes precedence over the NonDataDescriptor.

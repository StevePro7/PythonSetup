Summary
Let's summarize. As we've seen, the descriptor protocol itself is very simple, which can lead to some very concise and declarative code, which hugely reduces duplication. At the same time, implementing descriptors correctly can be tricky, and requires careful testing. In this module we reviewed the built-in property decorator. We demonstrated how to create property descriptors without using decorator syntax by passing property getters and setters directly to the property constructor. These reinforce the notion that properties create objects called descriptors, which are bound to class attributes. We showed how to implement a simple descriptor to perform a basic attribute validation check by creating a class that implemented the descriptor protocol. We explained how descriptor instances have no knowledge of to which class attributes they are bound, so each descriptor instance must store the instance attributes for all descriptor owner instances. This can be achieved by using a WeakKeyDictionary from the Python standard library Weak Ref module. We looked at how to know when descriptors are retrieved from their owning classes rather than via instances by detecting when the instance argument to dunder get is set to none. A natural course of action in such cases is to return the descriptor instance itself. We explained the distinction between data and non-data descriptors, and how this relates to attribute lookup precedence. We're not quite done with the descriptors yet, and in particular, we'd like descriptor instances to know the name of the class attributes to which they have been bound, but to solve that problem we need sharper tools in the form of Python's meta classes, which we'll be covering next. Thanks for watching, and we'll see you in the next module.

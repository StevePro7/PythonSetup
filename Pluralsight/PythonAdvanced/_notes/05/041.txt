Instance Creation
Instance Creation
Hello. My name is Robert Smallshire. Welcome to the fifth module of the Advanced Python course. In this course module we'll be taking a deep dive into exactly what happens when we create a new object. With this knowledge in hand we'll be able to exercise fine control over instance creation, which allows us to customize Python objects in powerful ways. So, what does happen when you create an object? Consider this simple class which models the coordinates on a chess board consisting of a file letter from a to h inclusive, and a rank number from one to eight inclusive. The class implements an immutable value type. The initializer establishes the invariance, and the property accessors prevent inadvertent modification of the encapsulated data. It's easy to think of dunder init as the construct implementation, but let's look closely at what happens when we create an instance of chess coordinate by calling the constructor. Here we create an instance called white_queen at coordinate (d, 4). We'll step in with the debugger, pausing on the first line of dunder init. This much should already be evident from the signature of dunder init, which accepts self as its first argument, but the object referred to by self already exists. That is to say, the object has already been constructed, and the job of dunder init really is just to initialize the object. At this juncture our debugger is having difficulty displaying the uninitialized object because our dunder repr implementation, quite reasonably, expects that the object has been initialized. However, we can add a watch in the debugger for type self to see that self already has the required type, and self. dunder dict to see that the instance dictionary is empty. As we continue to step through the initializer we can watch as the instance dictionary is populated by assignments to attributes of self. Behind the scenes, object. dunder setattr is being called. Note also that dunder init doesn't return anything. It simply mutates the instance it has been given. So if dunder init isn't responsible for creating the instance, what is? If we look at the special methods of ChessCoordinate using a call to dir we can see one called dunder new. We haven't defined dunder new ourselves, but we do inherit an implementation from the universal base class object, so it is the base class implementation of dunder new, which is responsible for allocating our object in this case. A simple test demonstrates that ChessCoordinate. dunder new is in fact the very same method as object. dunder new, but what is the signature of dunder new? Don't bother looking in the help because, frankly, the answer isn't very helpful. We have all the answers though, and we'll be overriding dunder new to demonstrate.

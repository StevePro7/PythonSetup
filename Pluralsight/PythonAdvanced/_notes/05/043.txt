Customizing Allocation
Now let's look at customizing allocation by overriding dunder new. We've shown the mechanics of overriding dunder new. We accept the class type and the constructor arguments and return an instance of the correct type. Ultimately, the only means we have of creating new instances is by calling object. dunder new. This is all well and good, but what are some practical uses? One use for controlling instance creation is a technique called interning, which can dramatically reduce memory consumption. We'll demonstrate by extending our program to allocate some chess boards in the start of game configuration. In our implementation each board is represented as a dictionary mapping the name of the piece to one of our ChessCoordinate objects. For fun we've used Unicode chess code points to represent our pieces. In our program a string comprised of white queen and white rook means white queen's rook, and a string composed of black king, black bishop, black pawn means black king's bishop's pawn. We need to be this specific because, remember, dictionaries require that keys are distinct. Our revised program now has a starting board function and main creates, for the time being, a single search board. We've also removed the various print statements from our dunder new and dunder init functions. If we create a single chess board this way a peek in activity monitor on our Mac shows that Python is allocated about 17. 1Mb of memory. Creating 10, 000 chessboards utilizes some 84. 2Mb of memory to store the 320, 000 instances of ChessCoordinate contained by the 10, 000 dictionaries that must have been created to represent all the boards. Bear in mind, though, that there are only 64 distinct positions on a chess board, and given that our ChessCoordinate objects are deliberately immutable value types, we should never need more than 64 instances. In our specific case, we should never need more than the 32 positions occupied by the pieces in their initial places. Let's put in place updated definitions for dunder new and dunder init, which achieve just that. We're now using named position arguments for the file and rank arguments to dunder new, and we'll move the validation logic from dunder init to dunder new. Once the arguments are validated we use them to create a single tuple object from file and rank to use as a key, and check if there is an entry against this key tuple in a dictionary called _interned we've attached as a class attribute. Only if the tuple key is not present in the dictionary do we allocate a new instance by calling object. dunder new. We then configure the new instance during the remainder of the work that used to be done in dunder init, and insert the newly minted instance into the dictionary. Of course, the instance we return is whichever instance we have just or previously inserted into the dictionary. Our dunder init method is now empty and can, in fact, be removed entirely. With these changes in place allocating 10, 000 boards takes much less memory than previously. In fact, we're down to 37. 1Mb, less than half what we required previously. Remember that even though we've interned the ChessCoordinate type we still have to store 10, 000 distinct dictionaries representing the board configurations. Interning is a powerful tool for managing memory usage. In fact, Python uses it internally for integers and strings, but it should only be used for immutable value types, such as our ChessCoordinate where instances can safely be shared between data structures.

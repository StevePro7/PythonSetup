Class Allocation and Initialization
Roughly speaking, when we write a class block in our Python source code it is syntactic sugar for creating a dictionary. The Python runtime populates the namespace dictionary while reading the contents of the class block, which is passed to a metaclass to convert the dictionary into a class object. To see how that works it's important to understand the several tasks that metaclasses perform during creation of a new class. When we write class Widget what's actually happening is something like this, which is to say that the class name is Widget, the metaclass is type, the class has no base classes, other than the implicit object, no keyword arguments were passed to the metaclass, we'll cover what this means later. The metaclasses, dunder prepare method is called to create a new namespace object, which behaves like a dictionary. Behind the scenes the Python runtime populates the namespace dictionary while reading the contents of the class block. The metaclasses dunder new method is called to allocate the class object, and finally, the metaclasses dunder init is called to initialize the class object. The name, bases, and namespace arguments contain the information collected during execution of the class definition, normally the class attributes and method definitions inside the class block, although in our case, the class block is logically empty. By providing our own metaclass we can customize these behaviors. We'll start with a very simple metaclass called TracingMeta in a module, tracing. py, which simply prints its method invocations and return values to the console for each of dunder prepare, dunder new, and dunder init. Notice that our metaclass should be a subclass of an existing metaclass, so we'll subclass type. Each of our overrides delegates to the base class type method to do the actual work required via a call to super. Notice that although dunder new is implicitly a class method, we must explicitly decorate the dunder prepare class method with the appropriate decorator. Now we'll define a class containing a simple method called action, which just prints a message, and a single class attribute, the answer, with the cosmically inevitable value 42. We'll do this at the REPL, so you can see clearly when the metaclass machinery is invoked. At the instant we complete the class definition we can see from the tracing output that Python executes the dunder prepare, dunder new, and dunder init method in turn. First of all, let's look at dunder prepare, the purpose of which is to produce an initial mapping object to contain the class namespace. The mcs argument, short for metaclass, is a reference to the metaclass itself. This first argument is analogous to the self-argument passed to instance methods, and the cls argument passed to class methods. For metaclass methods it is conventionally called mcs. The name argument contains the name of our Widget class as a string. The bases argument is an empty tuple. We didn't declare any base classes for widget, and the ultimate object based class is implicit. The kwargs argument is an empty dictionary. We'll cover the significance of this shortly. The most important aspect of dunder prepare is that when it calls it's super class implementation in type the return value is a dictionary or, more generally, a mapping type. In this case, it's a regular, empty dictionary. This dictionary will be the namespace associated with the nascent class. Moving on to looking detail at dunder new, the purpose of which is to allocate the new class object, the mcs argument is a reference to the metaclass as before. The name and bases arguments are still the string name of the new class and the tuple of base classes. The mapping object we returned from dunder prepare is passed as the namespace argument to dunder new. The Python runtime has populated this dictionary with several entries, as it has processed the class definition of widget. Two of the items are our action method and the the answer class attribute. The other two items are dunder module and dunder qualname, which the Python runtime has added. The dunder module attribute is mapped in the name of the module in which the class was defined. Because we use the REPL this is built-ins. The dunder qualname attribute contains the fully qualified name of the class, including parent modules and packages. In this case, it just contains the class name, as the built-in's module used by the REPL is available everywhere, being the last namespace in the LEGB lookup hierarchy. The kwargs dictionary passed to dunder new is also still empty. Within dunder new we delegate to the base class, type. dunder new, via a call to super, forwarding the mcs, name, bases, and namespace arguments. The object returned by this call is the new Widget class. We are in the process of allocating and configuring. The new Widget class is what we returned from dunder new. Note that any changes we wish to make to the contents of the namespace object must have been made before this call, as this is the point at which the class object is created. To change the contents of the class namespace after this call the class object must be manipulated directly. Finally, we come to dunder init, the purpose of which is to configure the newly created class object. Note that dunder init here is an instance method of the metaclass, not an explicit class method like dunder prepare or an implicit class method like dunder new. As such, it accepts cls as its first argument, which is one level less meta than cls. The name, bases, namespace, and kwargs arguments are all as before. Again, we delegate to the type base class via super, although dunder init doesn't return anything it's expected to it's expected to modify the existing class object that was handed to it. Note that although the namespace object is passed to dunder init, its content should already have been used upstream by dunder new when allocating the class object. Changes to namespace will be ineffectual, and any changes to the class object must be affected by manipulating cls directly. The key here is that metaclasses give us the opportunity to modify the dictionary of class attributes, which includes methods, before the class is instantiated. We even get the opportunity to modify the list of base classes or produce an entirely different class, if required, although such uses are rare. We'll look at some complex examples soon to make this clear. You may be wondering which out of dunder prepare, dunder new, and dunder init you should override. If you don't override dunder prepare the default implementation in type will produce a regular dictionary for the namespace object, so you only need to override it if you need the behavior provided by another mapping type. Usually it will only be necessary to override either dunder new or dunder init, but of these two only dunder new can make decisions before the new class is allocated. The distinction between dunder new and dunder init for metaclasses is exactly the same as it is for regular classes. Later we'll see that it might be wise to prefer a configuration in dunder init rather than dunder new, so that metaclasses are more composable.

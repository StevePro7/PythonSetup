Metaclass __call__ : The Instance Constructor
Now let's look at how to achieve very fine-grained instantiation control by overriding metaclass dunder call. For a moment return your thoughts to the material we covered in the previous module of this course when we looked at instance allocation with dunder new. We know that in order to create instances we call the constructor of the designed class. We have learned that behind the scenes this will call Widget. dunder new to allocate a widget followed by Widgit. dunder init, to do any further initialization. Let's pull back the curtain, and see exactly what is behind the scenes. The behavior of calling dunder new followed by dunder init when we call a constructor is actually the responsibility of dunder call on the metaclass. This makes sense when we remember that dunder call is a metamethod, and therefore can be called like a class method, and that dunder call makes the objects on which it is defined callable, like functions. This is the mechanism by which classes in Python become callable, and what we have been referring hither to as a constructor call is, in fact, the dunder call metamethod. Let's see this in action by overriding dunder call in our TracingMeta example. Within dunder call we print out its name and arguments, forward the call with super to the type metaclass, and then print out the return value from the super class. We'll also implement a TracingClass, which will use TracingMeta as its metaclass. Tracing class overrides dunder new and dunder init, so we can see when they're called. Notice that when we import the module into the REPL the metaclass trifecta, dunder prepare, dunder new, and dunder init are invoked when the TracingClass is defined. Now we'll instantiate TracingClass with a positional argument and a keyword argument to its constructor, 42 and keyword clef. Look carefully at the control flow here. Our call to the constructor invokes dunder call on the metaclass, which receives the arguments we passed to the constructor, in addition to the type we're trying to construct. Out dunder call override calls the super class implementation, which is type. dunder call in this case. See how type. dunder call in turn calls TracingClass. dunder new, followed by TracingClass. dunder init. In other words, it is type. dunder call, which orchestrates the default class allocation and initialization behavior. It is very rare to see the dunder call metamethod overridden. It's pretty low level in Python terms, and provides some of the most basic Python machinery. That said, it can be powerful. In keywordmeta. py we have an example of a metaclass overriding dunder call, which prevents classes, which use the metaclass, excepting positional arguments to their constructors. In dunder call we detect if args is non-empty, and if that's the case we raise a type error. We've also defined a regular class called ConstrainedToKeywords, which uses KeywordsOnlyMeta as its metaclass. Even though the dunder init method in ConstrainedToKeywords accepts positional arguments through *args, execution never gets this far, as non-empty positional argument lists are intercepted by dunder call in the KeywordsOnlyMeta metaclass, which causes a type error to be raised. Constructor calls which contain only keyword arguments are permitted, as we designed. We've covered a lot of the theory and practice behind metaclasses. Now well build on those ideas with some useful applications.

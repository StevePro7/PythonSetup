Naming Descriptors Using Metaclasses
For our next metaclass example let's return to the Planet example we used in a previous course module to illustrate descriptors. Here's a reminder of the code we ended up with. Recall that we implemented a new descriptor type called Positive, which would only emit positive numeric values. This saved a lot of boilerplate code in the definition of our Planet class, but we lost an important capability along the way because there is no way for a descriptor instance to know to which class attribute it has been bound. One of the instances of positive is bound to Planet. radius_metres, but it has no way of knowing that. The default Python machinery for processing class definitions just doesn't set up that association. The shortcoming is revealed when we trigger a value error by trying to assign a non-positive value to one of the attributes. Here we try to give the planet Mercury a nonsensical negative mass of -10, 000. The error message doesn't, and in fact, can't tell us which attribute triggered the exception. Now we'll show how we can modify the class creation machinery by defining a metaclass which can intervene in the process of defining the Planet class in order to give each descriptor instance the right name. We'll start by introducing a new base class for our descriptors called Named. This is very simple and just has name as a public instance attribute. The constructor defines a default value of none because we won't be in a position to assign the attribute value until after the descriptor object has been constructed. We'll modify our existing positive descriptor, so it becomes a subclass of named, and therefore gains the name attribute. Again, the constructor arguments define a default of none. We've modified the argument listed, dunder init, ensured that the super class initializer is called, and made use of the new name attribute in the error messages raised by dunder set and dunder delete. Now we need a metaclass which can detect the presence of descriptors which are named, and assign the class attribute names to them. Here is DescriptorNamingMeta. Again, this is fairly straightforward. In dunder new we iterate over the names and attributes in the namespace dictionary, and if the attribute is an instance of named we assign the name of the current item to its public name attribute. Having modified the contents of the namespace we then call the super class implementation of dunder new to actually allocate the new class object. The only change we need to make to our Planet class is to refer to the metaclass on the opening line. There's no need for us to modify the uses of our positive descriptor. The optional name argument will default to none when the class definition is first read before the metaclass dunder new is invoked. By trying to set a non-positive mass for the planet Mercury we can see that each descriptor object now knows the name of the attribute to which it has been bound, so it can emit a much more helpful diagnostic message, such as Attribute value mass_kilograms -10000 is not positive, allowing us to much more easily track down the problem.

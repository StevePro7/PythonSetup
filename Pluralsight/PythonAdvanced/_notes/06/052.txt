Metaclasses and Inheritance
We'll finish off this module by looking at how metaclasses interact with inheritance. Let's define two metaclasses, MetaA and MetaB, related only by the fact that they both subclass type. Both metaclasses will be empty. We'll also define two regular classes, A and B, which use MetaA and MetaB as their respective subclasses. Now we'll introduce a third class, D, which derives from class A. Now let's introspect class D itself, not an instance of D with type D to determine what its metaclass is. The metaclass of D is MetaA, which was inherited from its regular base class A, so metaclasses are inherited, but what happens if we try to create a new class C, which inherits from both regular classes A and B with their different metaclasses, MetaA and MetaB? Let's give it a go. When we try to execute this code by importing it at the REPL we get a type error with the message, metaclass conflict: the metaclass of a derived class must be a (non-strict) subclass of the metaclasses of all its bases. Python is telling us it doesn't know what to do with the unrelated metaclasses, MetaA and MetaB. Which metaclass dunder new should be used to allocate the class object? To resolve this we need a single metaclass. Let's call it MetaC, which we can create by inheriting from both MetaA and MetaB. In the definition of regular class C we must override the metaclass to specify MetaC. With these changes we can successfully import C and check that its metaclass is MetaC by asking for the type of C. So we've persuaded Python to accept our code, but our metaclasses are empty, so combine trivially. Sometimes metaclasses will combine in straightforward ways. For example, our ProhibitDuplicatesMeta, which overrides only dunder prepare, and our KeywordsOnlyMeta, which overrides only dunder call, can be combined into the conceptually simple, but horribly named, ProhibitDuplicatesAndKeywordsOnlyMeta, which can have an empty class body, but combine both behaviors. To cooperate gracefully non-trivial metaclasses must be designed with this in mind, which isn't always straightforward or even possible if the combination makes no sense. An important step in designing cooperative metaclasses is to diligently use super when delegating to base classes because, as we learned in Python Beyond the Basics, super actually delegates to the next class in the method resolution order or MRO, which accounts for multiple inheritance. Even though both our TracingMeta class we defined earlier, and the DescriptorNamingMeta metaclass we used with the Planet attributes both override dunder new, they combine easily in either order because our implementations delegate to the next class in the MRO chain using calls to super. In planet. py we can import TracingMeta, and combine our two metaclasses into TracingDescriptorNamingMeta with multiple inheritance. The planet class definition is executed when we import the module. This is when the metaclasses do their work, and we can see that tracing works as expected. We can also confirm that the descriptor naming is working by causing a value error and checking for the descriptor name in the error message. The two metaclasses cooperate successfully by using super. Another tip for designing metaclasses which cooperate well is to prefer to put code which configures the class object in the dunder init metamethod, which is handed the class object to be configured rather than the dunder new metamethod, which is responsible for allocating the new class object. Of course, each object may be only allocated once, but could be configured multiple times. Ultimately though, if you're dependent on metaclasses from a third party framework, such as SQLAlchemy or Qt, there's a good chance their metaclasses won't compose gracefully. You should be able to figure out whether they will compose by reading their source code if you have access to it.

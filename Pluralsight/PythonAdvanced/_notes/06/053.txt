Summary
We've covered a lot of ground in this course module, and you should now know more than the majority of Python developers about the customization of class creation using metaclasses. All classes have a metaclass, which is the type of the class object. The default type of class objects is type. The metaclass is responsible for processing the class definition parsed from the source code into a class object. The dunder prepare metaclass method must return a mapping object, which the Python runtime will populate with the namespace items collected from parsing and executing the class definition. The dunder new metaclass method must allocate and return a class object and configure it using the contents of the class namespace, the list of base classes passed from the definition and any additional keyword arguments passed from the definition. The dunder init metaclass can be used to further configure the class object and must have the same signature as dunder new. The dunder call metaclass method, in effect, implements the constructor for instances of the class, and is invoked when we construct an instance. An important use case for metaclasses is to support so-called named descriptors, whereby we can configure descriptor objects, such as properties, with the name of the class attribute to which they are assigned. Strict rules control how multiple metaclasses interact in the presence of inheritance relationships between the regular classes which use them. Judicial metaclass design using super to delegate via the MRO can yield metaclasses which compose gracefully. Thanks for watching, and we'll see you in the next module where we'll look at a simpler, but less capable alternative to metaclasses for many uses, class decorators.

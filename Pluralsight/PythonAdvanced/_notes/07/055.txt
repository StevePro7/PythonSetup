Enforcing Class Invariants
To do this in a generic way we need to provide a way of specifying the class invariant to the class decorator. Recall from our earlier work with function decorators, in Python Beyond the Basics, to do this we define a function accepting the arguments we need, which in turn returns a decorator. A predicate function which describes the invariant will be passed to a factory function, a class decorator factory, if you will, which creates the actual class decorator, which processes the definition of the temperature class. As the temperature class is processed by the class decorator each callable member of the class is identified in turn. These are the methods of the temperature class, and a function decorator is applied to each method. When invoked, the method decorators delegate to the original predicate function to verify the invariant. There's a lot going on here, so let's look at the code. The invariant function, which is, in effect, a decorator factory, accepts a predicate function, which is used to test the invariant, and returns the invariant_checking_class_decorator function. The class decorator accepts the class object as cls and builds a list of method names by identifying the callable attributes. Each method is then processed by a function called wrap_method_with_invariant_checking_proxy, which creates a function decorator for each method, which calls the method, and then checks that the invariant predicate still holds. Note that we must use setattr to update the class namespace, rather than manipulating the class dunderdict directly, as the latter is not mutable. We can now define our temperature class like this, calling the invariant class decorator function and passing to it our not_below_absolute_zero predicate function. Our predicate function is defined as our free function, not_below_absolute_zero, which simply tests the _kelvin private attribute. The predicate function necessarily directly accesses the private attributes of the temperature class. That's fine. The class and the function are very closely related. Creating non-negative temperatures works as expected. Here we create a temperature of 5 Kelvin, but an attempt to construct a negative temperature, here we tried to create a temperature of -1 Kelvin, demonstrates that our class decorator has successfully wrapped dunder init with the function decorator which checks the invariant. Likewise, the function decorator successfully wraps set Kelvin. After constructing a temperature of 42 Kelvin we tried to modify the temperature to -1 Kelvin, and the runtime error is raised. Before we get too excited, let's see what happens if we introduce some properties, defined using the property decorator into our Temperature class. We've added properties to get and set the temperature in both Celsius and Farenheit. We create a temperature of 42 Kelvin, which is reported back to us by the Celsius getter as about -231 Celsius. This is fine. Now let's set the Celsius to -100. That's fine because -100 Celsius is well above absolute zero. This works without a hitch, and the temperature is reported back to us in Celsius accurately. Now let's try to set a temperature of -300 Celsius, which is well below absolute 0. At this point, we should have received a runtime error, as -300 Celsius is less than absolute 0 Kelvin; however, no exception is raised, and the class invariant has been violated. If we try to get the Kelvin value via the get_kelvin method we do indeed get an error, but this is too late. Class invariant violations should never be detected by non-mutating getters or other query methods. A breach in our defenses has permitted the object to get into an invalid state. How is our invariant check being circumvented?

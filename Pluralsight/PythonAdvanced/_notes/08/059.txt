Abstract Base Classes
Introducing Abstract Base Classes
Hello. My name is Robert Smallshire. In this course module we'll be investigating the abstract base class mechanism in Python as originally defined in PEP 3119. We previously used some abstract base classes, such as Sequence from the collections. abc module in our Python Beyond the Basics course when implementing a sorted set collection type. This time we'll look at the tools provided in the Python standard library ABC module for creating abstract base classes of your own design. If you're coming to Python from another object oriented language, such as Java, C++, or C# you may have preconceived ideas of what an abstract base class is and how to use one. Beware though, the abstract base class mechanism in Python is much more flexible and can work in what may seem to be very surprising ways, so pay attention. Thinking for a moment beyond the confines of Python, what is, in general, an abstract base class? The clue is in the name. Base refers to the fact that the class is intended to be the target of an inheritance relationship. That is, we expect another class to derive from the base class. For instance, GraphicalDevice here is intended as the base class for other classes, such as our EpsonWF3520PrinterDriver. Abstract refers to the fact that the class cannot be instantiated in isolation. That is, it makes no sense to create an object of the type of the base class alone. It only makes sense to instantiate the class as part of an object of a derived type. Ideally, it should not be possible to instantiate an abstract base class directly. The opposite of abstract is concrete, and in this example the PrinterDriver is a concrete class, so it makes sense to instantiate it. The rational for any abstract base class is to define an interface which derived classes must implement. This allows client code to be written against the base class interface. In this example the PrinterDriver must override the three abstract methods of GraphicalDevice. Done diligently, this leads to a highly desirable property of class hierarchies called Liskov Substitutability, a design principle which states that subclasses, from the point of view of the client code, should be interchangeable. In other words, client code developed against an abstract interface should not require knowledge of specific concrete types, only of the capabilities as promised by the abstract base class. For example, code written against the interface of GraphicalDevice should be able to render to an EpsonWF3520Printer or a 1080p LcdDisplay without modification. We can substitute one concrete class for another. Abstract base classes differ from pure interfaces, such as those we have in languages like Java, insofar as they can also contain implementation code, which is to be shared by all derived classes. Why do we need to define named interfaces when we have duck typing? Isn't it sufficient to know whether a particular object responds to the interface of a duck, and behaves like a duck without actually knowing that it is a duck? In Python this is true both in theory and practice, but determining whether a particular object supports the required interface in advance of exercising that interface can be quite awkward. For example, what does it mean in Python to be a MutableSequence? We know that list is a MutableSequence, but we can't assume that all mutable sequences are lists. In fact, the MutableSequence protocol requires at least 16 methods are implemented. When relying on duck typing it can be difficult to be sure that you've met the requirements, and if clients do need to determine whether a particular object is admissible as a mutable sequence with a look before you leap approach the check is messy and awkward to perform robustly.

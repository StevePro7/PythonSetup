Abstract Base Classes in Python
Abstract base classes in Python serve two purposes. First of all, they provide a mechanism for defining protocols or interfaces, and ensuring the implementers of those protocols meets some minimum requirements. Secondly, they provide a means for easily determining whether an arbitrary class or instance meets the requirements of a specific protocol. For instance, after importing MutableSequence from the collections. abc module. We can determine that list is a MutableSequence using the built-in, issubclass function. This much may not be surprising, but let's look at the base class of list. In fact, we'll look at the transitive base classes of list by examining its method resolution order using the dunder mro attribute. This reveals that list has only one base class, object, and that MutableSequence is nowhere to be seen. Further reflection, if you'll excuse the pun, might lead you to wonder how it is that such a fundamental type as Python's list can be a subclass of a type defined in a library module. We've started out with this curious example, so as to efficiently disabuse migrants from other programming languages of any existing notions of what abstract base classes are, how they work, how they are used, and why they are useful. That done, we'll dig further into the mechanism. Let's establish that MutableSequence is indeed abstract by attempting to directly instantiate it. This fails with a useful type error explaining the five methods we need to implement the MutableSequence protocol. The reason we don't need to implement all 16 is that 11 of them can be implemented in terms of the other 5, and the MutableSequence abstract base class contains code to do exactly this. Note, however, that these implementations may not be the most efficient. Since they can't exploit knowledge of the concrete class, they must work entirely through the interface of the abstract class. Now to the question of how issubclass(list, MutableSequence) returns true. What happens is that when we call issubclass(list, MutableSequence) the built-in issubclass function checks for the existence of a method called dunder subclasscheck on the type of MutableSequence, which is to say, on the metaclass of MutableSequence, and if this method is present it is called with the subclass list as an argument. Issubclass(list, MutableSequence) is roughly equivalent to this code. It is up to the metaclass of MutableSequence to determine whether or not list is a subclass of MutableSequence, rather than list being required to know that MutableSequence is one of its base classes. This, in effect, allows list to be a subclass of MutableSequence without MutableSequence being a superclass of list in the normal sense of being the target of an inheritance relationship. We describe such base classes as virtual base classes, which has nothing at all to do with an identically named concept in C++. The dunder subclass check method on the metaclass of the virtual base class can do pretty much anything it likes to determine whether it's argument is to be considered a subclass.

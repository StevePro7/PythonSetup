Abstract Base Classes in Practice
Consider the code in weapons. py. In this module we've defined a Sword class with a metaclass, SwordMeta. SwordMeta defines the dunder subclasscheck method to check for the existence of callable swipe and sharpen attributes on the class. In this situation Sword will play the role of a virtual base class. A few simple tests at the REPL confirm that BroadSword and SamuraiSword are indeed considered subclasses of Sword, even though there is no explicit relationship through inheritance, so BroadSword is a subclass of Sword, SamuraiSword is a subclass of Sword, but Rifle is not a subclass of Sword. This isn't the whole story though, as tests of instances rather than classes using isinstance will return inconsistent results. Here we create an instance of SamuraiSword and try isinstance(samurai_sword, Sword). This is false. This is because the isinstance machinery checks for the existence of the dunder instancecheck method, which we have not yet implemented. Let's do so now. Our dunder instance check implementation simply delegates to dunder subclasscheck, which is called as a metamethod on the actual class, cls. With this change in place our call to isinstance produces a result consistent with the result from issubclass. This surprising technique is used in Python for some of the collection abstract base classes, including Sized, which is used to indicate whether we can determine the number of items in a collection with the built-in len function. Let's import Sized from collections. abc and create a new collection called SizedCollection, which just holds a simple integer size. SizedCollection implements dunder init to initialize the size, and dunder len to retrieve the size via the built-in len function. As you can see, implementing a dunder len method is sufficient to be considered a subclass of the Sized abstract base class. It's worth bearing in mind that our implementations of dunder instancecheck and dunder subclasscheck in SwordMeta are somewhat na√Øve, as they make no attempt to check the regular, non-virtual based classes of the objects being tested, which could lead to some surprising behavior. Bear in mind that correctly overriding dunder subclasscheck and dunder instancecheck on your own metaclasses is difficult. Don't worry though, we'll be presenting some more digestible alternatives shortly.

Non-transitive Subclass Relationships
Overriding subclasscheck affords class implementors a great deal of flexibility, so much flexibility, in fact, that not only should you not expect symmetry between the superclass and subclass relationships, you shouldn't expect transitivity of the subclass relationship. What this means is that if C is a subclass of B, and B is a subclass of A it doesn't necessarily follow that C is a subclass of A. One glaring example from Python revolves around the Hashable virtual base class from collections. abc. Let's import Hashable from collections. abc, and test whether object is hashable. Yes it is. Now let's test whether list is an object. Yes, of course it is. Now let's test whether the list is Hashable. No it is not, so even though list is an object, an object is a Hashable, we cannot say that list is a Hashable. This occurs because list, which remember is a mutable collection, disables hashing by removing the special dunder hash method, which would otherwise be inherited from object, and which the Hashable abstract base class checks for through its dunder subclass check implementation. Some further investigation reveals that the list class sets the dunder hash attribute to None. The Hashable dunder subclasscheck implementation checks for this eventuality and uses it to signal None hashability. This example is also interesting because it demonstrates the fact that even the ultimate base class object can be considered a subclass of Hashable, underlining the lack of symmetry between superclass and subclass relationships in Python.

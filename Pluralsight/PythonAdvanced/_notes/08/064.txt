Library Support for Abstract Base Classes
We've pointed out that implementing dunder subclasscheck and dunder instancecheck correctly can be awkward to get right. Fortunately, the standard library provides some support for implementing abstract base classes in the ABC module, the abc metaclass, along with some other useful pieces of infrastructure, including the ABC base class and the abstractmethod decorator. We'll cover each of these in detail now. The ABCMeta metaclass implements reliable dunder subclasscheck and dunder instancecheck methods, along with some other handy capabilities we'll come to shortly. We'll have our Sword class use ABCMeta instead of SwordMeta, which will allow us to dispose of SwordMeta after we've cannibalized it. Now, of course, ABCMeta doesn't know what it means to be a sword, so the test that was previously in SwordMeta dunder subclasscheck needs to be relocated elsewhere. The ABCMeta dunder subclasscheck method calls the special dunder subclasshook method on our actual class to perform the test. In fact, all Python objects have the dunder subclasshook class method, which accepts the potential subclass as its only argument. We can see this by calling it on object where it returns not implemented. The method should return True, False, or NotImplemented. For classes where dunder subclasshook returns NotImplemented the subclass test continues with the usual mechanism of testing the non-virtual base classes. Boolean values definitively indicate whether the argument class is to be considered a subclass of the base or not. Let's try implementing dunder subclasshook for our sword class with pretty much the same definition we use for dunder subclasscheck in SwordMeta previously. This class method, in conjunction with ABCMeta, is sufficient to make our issubclass and isinstance tests work as expected. SamuraiSword is a subclass of Sword, Rifle is not a subclass of Sword, and an instance of broad_sword is an instance of Sword.

Improving @invariant with ABCs
We rounded off the previous module of this course on class decorators by building a class decorator for checking class invariants after every method call and property access. This worked fine for both methods and properties with a single application of the decorator, but with chained invariant decorators the checking didn't work as planned for properties, with only the innermost invariant taking effect. Let's recap. Although the innermost lower bound check works when we try to assign a temperature of -300 Celsius through the Celsius setter, violating the upper bound with a temperature of 1*10 to the 34 Celsius is not detected as we had hoped. The problem here is that our class decorator is detecting specifically property instances with this fragment where we inspect each attribute of the class being decorated and check whether it is an instance of property. Because our property wrappers of type InvariantCheckingPropertyProxy are not detected as instances of property, they are not wrapped a second time, and the invariant specified in the outermost decorator is not enforced. We promised to use abstract base classes to fix this problem, so let's go. We'll introduce a new abstract base class called PropertyDataDescriptor, which inherits from the ABC convenience class, and which contains three abstract methods, which define the data descriptor protocol, dunder get, dunder set, and dunder delete. PropertyDataDescriptor also includes the abstract property, dunder isabstractmethod for correct propagation of abstractness. Note that because dunder isabstractmethod needs to look like an abstract attribute we have implemented it by applying the abstract method and property decorators in that order. Having defined an abstract base class, we now need some subclasses. The first will be a virtual subclass, the built-in property class, which will register with the base class by calling PropertyDataDescriptor. register(property). The second subclass will be a real subclass. We'll modify our existing property proxy, InvariantCheckingPropertyProxy, to inherit from PropertyDataDescriptor, which will also require that we override the dunder isabstractmethod property. In the implementation of dunder isabstractmethod we delegate the attribute of the same name on the referent property, which we are wrapping. Finally, we need to update the search and wrap logic in invariant checking class decorator to use the more general test for instances of PropertyDataDescriptor, rather than the more specific test for just property. With these changes in place, both invariants are enforced on property writes. We'll create a temperature of 42 Kelvin, then attempt to modify the temperature through the Celsius setter with a temperature of -300 Celsius, which is below absolute zero. This now fails as designed, signaling a violation of the temperature not below absolute zero invariant. Then we test the other invariant by assigning a temperature of 1*10 to the 34 through the Celsius setter. This also fails as designed, signaling a violation of the temperature below absolute hot classing variant. There's a lot going on in this code with decorators, metaclasses, abstract base classes, and descriptors, and it may seem somewhat complicated. All this complexity is well encapsulated in the invariant class decorator, so take a step back, and enjoy the simplicity of the client code in the temperature class.
